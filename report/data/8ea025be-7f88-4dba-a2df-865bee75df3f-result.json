{"name": "test_main[cases30]", "status": "broken", "statusDetails": {"message": "UnboundLocalError: local variable 'db' referenced before assignment", "trace": "@pytest.fixture(scope=\"session\")\n    def get_db():\n        \"\"\"关于其作用域请移步查看官方文档\"\"\"\n        try:\n>           db = DB()\n\ntest\\conftest.py:46: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <tools.db.DB object at 0x000001FFC87F9070>\n\n    def __init__(self):\n        \"\"\"\n        初始化数据库连接，并指定查询的结果集以字典形式返回\n        \"\"\"\n>       self.connection = pymysql.connect(\n            host=self.mysql['host'],\n            port=self.mysql['port'],\n            user=self.mysql['user'],\n            password=self.mysql['password'],\n            db=self.mysql['db_name'],\n            charset=self.mysql.get('charset', 'utf8mb4'),\n            cursorclass=pymysql.cursors.DictCursor\n        )\n\ntools\\db.py:27: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nargs = ()\nkwargs = {'charset': 'utf8mb4', 'cursorclass': <class 'pymysql.cursors.DictCursor'>, 'db': 'apiautotest', 'host': '192.168.5.120', ...}\nConnection = <class 'pymysql.connections.Connection'>\n\n    def Connect(*args, **kwargs):\n        \"\"\"\n        Connect to the database; see connections.Connection.__init__() for\n        more information.\n        \"\"\"\n        from .connections import Connection\n>       return Connection(*args, **kwargs)\n\nD:\\PythonCode\\apiAutoTest\\lib\\site-packages\\pymysql\\__init__.py:94: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pymysql.connections.Connection object at 0x000001FFC87F9040>\nhost = '192.168.5.120', user = 'root', password = 'password'\ndatabase = 'apiautotest', port = 3306, unix_socket = None, charset = 'utf8mb4'\nsql_mode = None, read_default_file = None\nconv = {<class 'bool'>: <function escape_bool at 0x000001FFC77EA0D0>, <class 'int'>: <function escape_int at 0x000001FFC77EA1...'>: <function escape_float at 0x000001FFC77EA280>, <class 'str'>: <function escape_unicode at 0x000001FFC77EA4C0>, ...}\nuse_unicode = True, client_flag = 3842573\ncursorclass = <class 'pymysql.cursors.DictCursor'>, init_command = None\nconnect_timeout = 10, ssl = None, read_default_group = None, compress = None\nnamed_pipe = None, autocommit = False, db = 'apiautotest', passwd = None\nlocal_infile = False, max_allowed_packet = 16777216, defer_connect = False\nauth_plugin_map = None, read_timeout = None, write_timeout = None\nbind_address = None, binary_prefix = False, program_name = None\nserver_public_key = None\n\n    def __init__(self, host=None, user=None, password=\"\",\n                 database=None, port=0, unix_socket=None,\n                 charset='', sql_mode=None,\n                 read_default_file=None, conv=None, use_unicode=None,\n                 client_flag=0, cursorclass=Cursor, init_command=None,\n                 connect_timeout=10, ssl=None, read_default_group=None,\n                 compress=None, named_pipe=None,\n                 autocommit=False, db=None, passwd=None, local_infile=False,\n                 max_allowed_packet=16*1024*1024, defer_connect=False,\n                 auth_plugin_map=None, read_timeout=None, write_timeout=None,\n                 bind_address=None, binary_prefix=False, program_name=None,\n                 server_public_key=None):\n        if use_unicode is None and sys.version_info[0] > 2:\n            use_unicode = True\n    \n        if db is not None and database is None:\n            database = db\n        if passwd is not None and not password:\n            password = passwd\n    \n        if compress or named_pipe:\n            raise NotImplementedError(\"compress and named_pipe arguments are not supported\")\n    \n        self._local_infile = bool(local_infile)\n        if self._local_infile:\n            client_flag |= CLIENT.LOCAL_FILES\n    \n        if read_default_group and not read_default_file:\n            if sys.platform.startswith(\"win\"):\n                read_default_file = \"c:\\\\my.ini\"\n            else:\n                read_default_file = \"/etc/my.cnf\"\n    \n        if read_default_file:\n            if not read_default_group:\n                read_default_group = \"client\"\n    \n            cfg = Parser()\n            cfg.read(os.path.expanduser(read_default_file))\n    \n            def _config(key, arg):\n                if arg:\n                    return arg\n                try:\n                    return cfg.get(read_default_group, key)\n                except Exception:\n                    return arg\n    \n            user = _config(\"user\", user)\n            password = _config(\"password\", password)\n            host = _config(\"host\", host)\n            database = _config(\"database\", database)\n            unix_socket = _config(\"socket\", unix_socket)\n            port = int(_config(\"port\", port))\n            bind_address = _config(\"bind-address\", bind_address)\n            charset = _config(\"default-character-set\", charset)\n            if not ssl:\n                ssl = {}\n            if isinstance(ssl, dict):\n                for key in [\"ca\", \"capath\", \"cert\", \"key\", \"cipher\"]:\n                    value = _config(\"ssl-\" + key, ssl.get(key))\n                    if value:\n                        ssl[key] = value\n    \n        self.ssl = False\n        if ssl:\n            if not SSL_ENABLED:\n                raise NotImplementedError(\"ssl module not found\")\n            self.ssl = True\n            client_flag |= CLIENT.SSL\n            self.ctx = self._create_ssl_ctx(ssl)\n    \n        self.host = host or \"localhost\"\n        self.port = port or 3306\n        if type(self.port) is not int:\n            raise ValueError(\"port should be of type int\")\n        self.user = user or DEFAULT_USER\n        self.password = password or b\"\"\n        if isinstance(self.password, text_type):\n            self.password = self.password.encode('latin1')\n        self.db = database\n        self.unix_socket = unix_socket\n        self.bind_address = bind_address\n        if not (0 < connect_timeout <= 31536000):\n            raise ValueError(\"connect_timeout should be >0 and <=31536000\")\n        self.connect_timeout = connect_timeout or None\n        if read_timeout is not None and read_timeout <= 0:\n            raise ValueError(\"read_timeout should be > 0\")\n        self._read_timeout = read_timeout\n        if write_timeout is not None and write_timeout <= 0:\n            raise ValueError(\"write_timeout should be > 0\")\n        self._write_timeout = write_timeout\n        if charset:\n            self.charset = charset\n            self.use_unicode = True\n        else:\n            self.charset = DEFAULT_CHARSET\n            self.use_unicode = False\n    \n        if use_unicode is not None:\n            self.use_unicode = use_unicode\n    \n        self.encoding = charset_by_name(self.charset).encoding\n    \n        client_flag |= CLIENT.CAPABILITIES\n        if self.db:\n            client_flag |= CLIENT.CONNECT_WITH_DB\n    \n        self.client_flag = client_flag\n    \n        self.cursorclass = cursorclass\n    \n        self._result = None\n        self._affected_rows = 0\n        self.host_info = \"Not connected\"\n    \n        # specified autocommit mode. None means use server default.\n        self.autocommit_mode = autocommit\n    \n        if conv is None:\n            conv = converters.conversions\n    \n        # Need for MySQLdb compatibility.\n        self.encoders = {k: v for (k, v) in conv.items() if type(k) is not int}\n        self.decoders = {k: v for (k, v) in conv.items() if type(k) is int}\n        self.sql_mode = sql_mode\n        self.init_command = init_command\n        self.max_allowed_packet = max_allowed_packet\n        self._auth_plugin_map = auth_plugin_map or {}\n        self._binary_prefix = binary_prefix\n        self.server_public_key = server_public_key\n    \n        self._connect_attrs = {\n            '_client_name': 'pymysql',\n            '_pid': str(os.getpid()),\n            '_client_version': VERSION_STRING,\n        }\n    \n        if program_name:\n            self._connect_attrs[\"program_name\"] = program_name\n    \n        if defer_connect:\n            self._sock = None\n        else:\n>           self.connect()\n\nD:\\PythonCode\\apiAutoTest\\lib\\site-packages\\pymysql\\connections.py:327: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pymysql.connections.Connection object at 0x000001FFC87F9040>\nsock = <socket.socket [closed] fd=-1, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0>\n\n    def connect(self, sock=None):\n        self._closed = False\n        try:\n            if sock is None:\n                if self.unix_socket:\n                    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n                    sock.settimeout(self.connect_timeout)\n                    sock.connect(self.unix_socket)\n                    self.host_info = \"Localhost via UNIX socket\"\n                    self._secure = True\n                    if DEBUG: print('connected using unix_socket')\n                else:\n                    kwargs = {}\n                    if self.bind_address is not None:\n                        kwargs['source_address'] = (self.bind_address, 0)\n                    while True:\n                        try:\n                            sock = socket.create_connection(\n                                (self.host, self.port), self.connect_timeout,\n                                **kwargs)\n                            break\n                        except (OSError, IOError) as e:\n                            if e.errno == errno.EINTR:\n                                continue\n                            raise\n                    self.host_info = \"socket %s:%d\" % (self.host, self.port)\n                    if DEBUG: print('connected using socket')\n                    sock.setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)\n                    sock.setsockopt(socket.SOL_SOCKET, socket.SO_KEEPALIVE, 1)\n                sock.settimeout(None)\n    \n            self._sock = sock\n            self._rfile = _makefile(sock, 'rb')\n            self._next_seq_id = 0\n    \n            self._get_server_information()\n>           self._request_authentication()\n\nD:\\PythonCode\\apiAutoTest\\lib\\site-packages\\pymysql\\connections.py:588: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pymysql.connections.Connection object at 0x000001FFC87F9040>\n\n    def _request_authentication(self):\n        # https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse\n        if int(self.server_version.split('.', 1)[0]) >= 5:\n            self.client_flag |= CLIENT.MULTI_RESULTS\n    \n        if self.user is None:\n            raise ValueError(\"Did not specify a username\")\n    \n        charset_id = charset_by_name(self.charset).id\n        if isinstance(self.user, text_type):\n            self.user = self.user.encode(self.encoding)\n    \n        data_init = struct.pack('<iIB23s', self.client_flag, MAX_PACKET_LEN, charset_id, b'')\n    \n        if self.ssl and self.server_capabilities & CLIENT.SSL:\n            self.write_packet(data_init)\n    \n            self._sock = self.ctx.wrap_socket(self._sock, server_hostname=self.host)\n            self._rfile = _makefile(self._sock, 'rb')\n            self._secure = True\n    \n        data = data_init + self.user + b'\\0'\n    \n        authresp = b''\n        plugin_name = None\n    \n        if self._auth_plugin_name == '':\n            plugin_name = b''\n            authresp = _auth.scramble_native_password(self.password, self.salt)\n        elif self._auth_plugin_name == 'mysql_native_password':\n            plugin_name = b'mysql_native_password'\n            authresp = _auth.scramble_native_password(self.password, self.salt)\n        elif self._auth_plugin_name == 'caching_sha2_password':\n            plugin_name = b'caching_sha2_password'\n            if self.password:\n                if DEBUG:\n                    print(\"caching_sha2: trying fast path\")\n                authresp = _auth.scramble_caching_sha2(self.password, self.salt)\n            else:\n                if DEBUG:\n                    print(\"caching_sha2: empty password\")\n        elif self._auth_plugin_name == 'sha256_password':\n            plugin_name = b'sha256_password'\n            if self.ssl and self.server_capabilities & CLIENT.SSL:\n                authresp = self.password + b'\\0'\n            elif self.password:\n                authresp = b'\\1'  # request public key\n            else:\n                authresp = b'\\0'  # empty password\n    \n        if self.server_capabilities & CLIENT.PLUGIN_AUTH_LENENC_CLIENT_DATA:\n            data += lenenc_int(len(authresp)) + authresp\n        elif self.server_capabilities & CLIENT.SECURE_CONNECTION:\n            data += struct.pack('B', len(authresp)) + authresp\n        else:  # pragma: no cover - not testing against servers without secure auth (>=5.0)\n            data += authresp + b'\\0'\n    \n        if self.db and self.server_capabilities & CLIENT.CONNECT_WITH_DB:\n            if isinstance(self.db, text_type):\n                self.db = self.db.encode(self.encoding)\n            data += self.db + b'\\0'\n    \n        if self.server_capabilities & CLIENT.PLUGIN_AUTH:\n            data += (plugin_name or b'') + b'\\0'\n    \n        if self.server_capabilities & CLIENT.CONNECT_ATTRS:\n            connect_attrs = b''\n            for k, v in self._connect_attrs.items():\n                k = k.encode('utf-8')\n                connect_attrs += struct.pack('B', len(k)) + k\n                v = v.encode('utf-8')\n                connect_attrs += struct.pack('B', len(v)) + v\n            data += struct.pack('B', len(connect_attrs)) + connect_attrs\n    \n        self.write_packet(data)\n>       auth_packet = self._read_packet()\n\nD:\\PythonCode\\apiAutoTest\\lib\\site-packages\\pymysql\\connections.py:853: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pymysql.connections.Connection object at 0x000001FFC87F9040>\npacket_type = <class 'pymysql.protocol.MysqlPacket'>\n\n    def _read_packet(self, packet_type=MysqlPacket):\n        \"\"\"Read an entire \"mysql packet\" in its entirety from the network\n        and return a MysqlPacket type that represents the results.\n    \n        :raise OperationalError: If the connection to the MySQL server is lost.\n        :raise InternalError: If the packet sequence number is wrong.\n        \"\"\"\n        buff = bytearray()\n        while True:\n            packet_header = self._read_bytes(4)\n            #if DEBUG: dump_packet(packet_header)\n    \n            btrl, btrh, packet_number = struct.unpack('<HBB', packet_header)\n            bytes_to_read = btrl + (btrh << 16)\n            if packet_number != self._next_seq_id:\n                self._force_close()\n                if packet_number == 0:\n                    # MariaDB sends error packet with seqno==0 when shutdown\n                    raise err.OperationalError(\n                        CR.CR_SERVER_LOST,\n                        \"Lost connection to MySQL server during query\")\n                raise err.InternalError(\n                    \"Packet sequence number wrong - got %d expected %d\"\n                    % (packet_number, self._next_seq_id))\n            self._next_seq_id = (self._next_seq_id + 1) % 256\n    \n            recv_data = self._read_bytes(bytes_to_read)\n            if DEBUG: dump_packet(recv_data)\n            buff += recv_data\n            # https://dev.mysql.com/doc/internals/en/sending-more-than-16mbyte.html\n            if bytes_to_read == 0xffffff:\n                continue\n            if bytes_to_read < MAX_PACKET_LEN:\n                break\n    \n        packet = packet_type(bytes(buff), self.encoding)\n        if packet.is_error_packet():\n            if self._result is not None and self._result.unbuffered_active is True:\n                self._result.unbuffered_active = False\n>           packet.raise_for_error()\n\nD:\\PythonCode\\apiAutoTest\\lib\\site-packages\\pymysql\\connections.py:676: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <pymysql.protocol.MysqlPacket object at 0x000001FFC87F94C0>\n\n    def raise_for_error(self):\n        self.rewind()\n        self.advance(1)  # field_count == error (we already know that)\n        errno = self.read_uint16()\n        if DEBUG: print(\"errno =\", errno)\n>       err.raise_mysql_exception(self._data)\n\nD:\\PythonCode\\apiAutoTest\\lib\\site-packages\\pymysql\\protocol.py:223: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\ndata = b\"\\xff\\x19\\x04#42000Unknown database 'apiautotest'\"\n\n    def raise_mysql_exception(data):\n        errno = struct.unpack('<h', data[1:3])[0]\n        errval = data[9:].decode('utf-8', 'replace')\n        errorclass = error_map.get(errno)\n        if errorclass is None:\n            errorclass = InternalError if errno < 1000 else OperationalError\n>       raise errorclass(errno, errval)\nE       pymysql.err.OperationalError: (1049, \"Unknown database 'apiautotest'\")\n\nD:\\PythonCode\\apiAutoTest\\lib\\site-packages\\pymysql\\err.py:107: OperationalError\n\nDuring handling of the above exception, another exception occurred:\n\n    @pytest.fixture(scope=\"session\")\n    def get_db():\n        \"\"\"关于其作用域请移步查看官方文档\"\"\"\n        try:\n            db = DB()\n            yield db\n        finally:\n>           db.close()\nE           UnboundLocalError: local variable 'db' referenced before assignment\n\ntest\\conftest.py:49: UnboundLocalError"}, "parameters": [{"name": "cases", "value": "['c31', '条件表达式标签关闭', '{\"Authorization\": \"${token}\"}', 'condition/update', 'post', 'json', '', '{\"servicename\":\"服务1\",\"tags\":[{\"tagname\":\"标签1\",\"address\":[\"432.1.3.5\"]}],\"enabled\":false}', '', '', '{\"$.data.servicename\": \"服务1\"}']"}], "start": 1641434048777, "stop": 1641434048777, "uuid": "25c20a80-357e-471c-9702-0a5bb3da89c4", "historyId": "bb0c37b9c605c220cf87009ad35ae750", "testCaseId": "881516e7ef2e2aa5436f6a3c3e6a5bcb", "fullName": "test.test_api#test_main", "labels": [{"name": "parentSuite", "value": "test"}, {"name": "suite", "value": "test_api"}, {"name": "host", "value": "DESKTOP-BNVFIE4"}, {"name": "thread", "value": "16688-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test.test_api"}]}